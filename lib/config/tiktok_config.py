"""TikTok automation configuration management."""

import os
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, List, Dict, Any


@dataclass
class TikTokCredentials:
    """TikTok authentication credentials configuration."""
    
    username: Optional[str] = None
    password: Optional[str] = None
    cookies_file: str = "tiktok_cookies.json"
    
    @classmethod
    def from_environment(cls) -> 'TikTokCredentials':
        """Create credentials from environment variables.
        
        Returns:
            TikTokCredentials instance with values from environment
        """
        return cls(
            username=os.getenv('TIKTOK_USERNAME'),
            password=os.getenv('TIKTOK_PASSWORD'),
            cookies_file=os.getenv('TIKTOK_COOKIES_FILE', 'tiktok_cookies.json')
        )
    
    def validate(self) -> bool:
        """Validate that required credentials are present.
        
        Returns:
            True if username and password are present, False otherwise
        """
        return bool(self.username and self.password)


@dataclass
class TikTokUploadConfig:
    """Configuration for TikTok video uploads."""
    
    default_title: str = "MoneyTree Generated Video"
    default_description: str = "Educational content generated by MoneyTree"
    default_tags: List[str] = None
    default_privacy: str = "public"  # public, private, friends
    max_title_length: int = 150
    max_description_length: int = 2200
    
    def __post_init__(self):
        """Initialize default values after dataclass creation."""
        if self.default_tags is None:
            self.default_tags = ["education", "ai", "moneytree", "learning"]
    
    @classmethod
    def from_topic(cls, topic: str) -> 'TikTokUploadConfig':
        """Create upload config customized for a specific topic.
        
        Args:
            topic: The topic being uploaded about
            
        Returns:
            TikTokUploadConfig with topic-specific defaults
        """
        clean_topic = topic.lower().replace(" ", "").replace("-", "")
        return cls(
            default_title=f"{topic} - Educational Content",
            default_description=f"Learn about {topic} with MoneyTree's AI-generated educational content! #education #ai #learning",
            default_tags=["education", "ai", "moneytree", "learning", clean_topic]
        )
    
    def format_title(self, title: str, tags: Optional[List[str]] = None) -> str:
        """Format title with tags, respecting length limits.
        
        Args:
            title: Base title text
            tags: Optional list of hashtags to append
            
        Returns:
            Formatted title with hashtags
        """
        if not tags:
            tags = self.default_tags
        
        hashtags = ' '.join([f'#{tag}' for tag in tags])
        full_title = f"{title} {hashtags}"
        
        if len(full_title) <= self.max_title_length:
            return full_title
        
        # Truncate title to fit with hashtags
        available_length = self.max_title_length - len(hashtags) - 1
        truncated_title = title[:available_length].strip()
        return f"{truncated_title} {hashtags}"


@dataclass
class TikTokSeleniumConfig:
    """Configuration for Selenium WebDriver automation."""
    
    headless: bool = True
    implicit_wait: int = 10
    page_load_timeout: int = 30
    script_timeout: int = 30
    upload_timeout: int = 300  # 5 minutes
    typing_delay: float = 0.1
    max_retries: int = 3
    retry_delay: int = 5
    
    # Browser options
    window_width: int = 1920
    window_height: int = 1080
    user_agent: str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    
    @classmethod
    def from_environment(cls) -> 'TikTokSeleniumConfig':
        """Create selenium config from environment variables.
        
        Returns:
            TikTokSeleniumConfig with values from environment
        """
        return cls(
            headless=os.getenv('TIKTOK_HEADLESS', 'true').lower() == 'true',
            implicit_wait=int(os.getenv('TIKTOK_IMPLICIT_WAIT', '10')),
            page_load_timeout=int(os.getenv('TIKTOK_PAGE_LOAD_TIMEOUT', '30')),
            upload_timeout=int(os.getenv('TIKTOK_UPLOAD_TIMEOUT', '300')),
            typing_delay=float(os.getenv('TIKTOK_TYPING_DELAY', '0.1')),
            max_retries=int(os.getenv('TIKTOK_MAX_RETRIES', '3'))
        )


@dataclass
class TikTokRateLimitConfig:
    """Configuration for TikTok rate limiting and timing."""
    
    upload_cooldown: int = 300  # 5 minutes between uploads
    daily_upload_limit: int = 10
    login_cooldown: int = 60  # 1 minute between login attempts
    max_concurrent_sessions: int = 1
    
    def estimate_daily_uploads(self) -> int:
        """Estimate maximum daily uploads based on rate limits.
        
        Returns:
            Maximum number of videos that can be uploaded per day
        """
        return min(self.daily_upload_limit, 
                  (24 * 60 * 60) // self.upload_cooldown)
    
    def calculate_upload_schedule(self, video_count: int) -> Dict[str, Any]:
        """Calculate optimal upload schedule for multiple videos.
        
        Args:
            video_count: Number of videos to upload
            
        Returns:
            Dictionary with scheduling information
        """
        max_daily = self.estimate_daily_uploads()
        
        if video_count <= max_daily:
            total_time = video_count * self.upload_cooldown
            return {
                'can_upload_today': True,
                'total_time_minutes': total_time // 60,
                'estimated_completion': f"{total_time // 3600}h {(total_time % 3600) // 60}m"
            }
        else:
            days_needed = (video_count + max_daily - 1) // max_daily
            return {
                'can_upload_today': False,
                'days_needed': days_needed,
                'videos_per_day': max_daily,
                'remaining_videos': video_count % max_daily
            }


class TikTokConfigManager:
    """Centralized TikTok configuration management."""
    
    def __init__(self, 
                 credentials: Optional[TikTokCredentials] = None,
                 upload_config: Optional[TikTokUploadConfig] = None,
                 selenium_config: Optional[TikTokSeleniumConfig] = None,
                 rate_limit_config: Optional[TikTokRateLimitConfig] = None):
        """Initialize TikTok configuration manager.
        
        Args:
            credentials: TikTok authentication credentials
            upload_config: Video upload configuration
            selenium_config: Selenium automation configuration
            rate_limit_config: Rate limiting configuration
        """
        self.credentials = credentials or TikTokCredentials.from_environment()
        self.upload_config = upload_config or TikTokUploadConfig()
        self.selenium_config = selenium_config or TikTokSeleniumConfig.from_environment()
        self.rate_limit_config = rate_limit_config or TikTokRateLimitConfig()
    
    def validate_configuration(self) -> Dict[str, Any]:
        """Validate all configuration components.
        
        Returns:
            Dictionary with validation results
        """
        result = {
            'valid': True,
            'issues': [],
            'warnings': []
        }
        
        # Check credentials
        if not self.credentials.validate():
            result['valid'] = False
            result['issues'].append("TIKTOK_USERNAME and TIKTOK_PASSWORD environment variables not set")
        
        # Check cookies file path
        cookies_path = Path(self.credentials.cookies_file)
        if not cookies_path.parent.exists():
            result['warnings'].append(f"Cookies directory does not exist: {cookies_path.parent}")
        
        # Check upload limits
        max_uploads = self.rate_limit_config.estimate_daily_uploads()
        if max_uploads < 1:
            result['warnings'].append(f"Rate limiting only allows {max_uploads} uploads per day")
        
        # Check selenium configuration
        if self.selenium_config.upload_timeout < 60:
            result['warnings'].append("Upload timeout may be too short for large videos")
        
        return result
    
    def get_upload_metadata(self, topic: str, **overrides) -> Dict[str, Any]:
        """Get complete upload metadata for a topic.
        
        Args:
            topic: The topic being uploaded about
            **overrides: Override default values
            
        Returns:
            Dictionary with upload metadata
        """
        topic_config = TikTokUploadConfig.from_topic(topic)
        
        title = overrides.get('title', topic_config.default_title)
        tags = overrides.get('tags', topic_config.default_tags)
        
        metadata = {
            'title': topic_config.format_title(title, tags),
            'description': overrides.get('description', topic_config.default_description),
            'tags': tags,
            'privacy': overrides.get('privacy', topic_config.default_privacy)
        }
        
        return metadata
    
    def get_selenium_options(self) -> Dict[str, Any]:
        """Get Selenium WebDriver options.
        
        Returns:
            Dictionary with Selenium configuration options
        """
        return {
            'headless': self.selenium_config.headless,
            'window_size': (self.selenium_config.window_width, self.selenium_config.window_height),
            'user_agent': self.selenium_config.user_agent,
            'implicit_wait': self.selenium_config.implicit_wait,
            'page_load_timeout': self.selenium_config.page_load_timeout,
            'script_timeout': self.selenium_config.script_timeout,
            'upload_timeout': self.selenium_config.upload_timeout,
            'typing_delay': self.selenium_config.typing_delay,
            'max_retries': self.selenium_config.max_retries
        }
    
    def check_upload_eligibility(self, video_count: int = 1) -> Dict[str, Any]:
        """Check if uploads can be performed based on rate limits.
        
        Args:
            video_count: Number of videos to upload
            
        Returns:
            Dictionary with upload eligibility information
        """
        schedule = self.rate_limit_config.calculate_upload_schedule(video_count)
        
        return {
            'can_upload': schedule.get('can_upload_today', False),
            'schedule': schedule,
            'rate_limits': {
                'daily_limit': self.rate_limit_config.daily_upload_limit,
                'cooldown_minutes': self.rate_limit_config.upload_cooldown // 60,
                'max_concurrent': self.rate_limit_config.max_concurrent_sessions
            }
        }
    
    @classmethod
    def create_default(cls) -> 'TikTokConfigManager':
        """Create a default configuration manager from environment.
        
        Returns:
            TikTokConfigManager with default settings
        """
        return cls()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert configuration to dictionary format.
        
        Returns:
            Dictionary representation of configuration
        """
        return {
            'credentials': {
                'has_username': bool(self.credentials.username),
                'has_password': bool(self.credentials.password),
                'cookies_file': self.credentials.cookies_file
            },
            'upload_config': {
                'default_title': self.upload_config.default_title,
                'default_description': self.upload_config.default_description,
                'default_tags': self.upload_config.default_tags,
                'default_privacy': self.upload_config.default_privacy,
                'max_title_length': self.upload_config.max_title_length
            },
            'selenium_config': {
                'headless': self.selenium_config.headless,
                'upload_timeout': self.selenium_config.upload_timeout,
                'typing_delay': self.selenium_config.typing_delay,
                'max_retries': self.selenium_config.max_retries
            },
            'rate_limit_config': {
                'daily_upload_limit': self.rate_limit_config.daily_upload_limit,
                'upload_cooldown': self.rate_limit_config.upload_cooldown,
                'max_daily_uploads': self.rate_limit_config.estimate_daily_uploads()
            }
        }